算法核心：贪心算法。
以用户输入的tags作为目标集合，查找数据库，每次找出tags与目标集合中重合最多的课程将其记录，再从目标集合中除去所选这门课的tags，以剩余的tags为目标集合，直到目标集合为空集合（找到了课程组合满足用户的输入）或者是目标集合无法再减小（找不到课程组合满足用户的输入）。如果在查找过程中，不止一门课与目标集合重合最多，那我们选择总时间更少的一门课。如果用户勾选了“self paced”选项，我们则优先查找总时间为self paced的课程，如果未能满足目标集合，再加入总时间为具体时间（如7 weeks）的课程。如果用户输入了一个时间（以周为单位），期望在这个时间内完成tags的目标（意味着用户无法再勾选self paced选项，二者只可择一），那我们将会计算，如果我们得出的课程组合时间总和超过了用户所输入的时间，则显示“在这个时间限制内没有结果”，要求用户输入一个更多的时间。如果得出的课程组合时间总和没有超过用户的输入，则将课程所有的相关信息列出显示给用户。
该算法易于实现，并且在绝大多数情况下都会得出比较理想的结果。然而，贪心算法并不能保证宏观上的最优组合，这就意味着我们得出的结果也许不是时间总和最短的结果。如用户输入C，Java，Python三个tag， 有如下课程可供选择：course1:C, 1 week; course2:Java, 1 week; course3:Python,1 week; course4:C,Java,Python, 5 weeks。可以看出最优的方案是选择前三个课程作为组合，可是在我们的算法中 会直接选择course4作为结果。幸运的是，这种情况是极其少见的。
未来的改进：对于贪心算法，我们能改进的并不是很多，也许以其他的因素作为贪心算法的目标会有不同的结果，不过其依然无法保证实现宏观上的最优。唯一的方法是使用更严谨的算法，来确保最优组合的产生，不过取而代之的是要牺牲更多的时间来实现和执行这个算法。